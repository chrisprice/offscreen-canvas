(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-scale'), require('d3-selection'), require('d3-path'), require('d3-shape'), require('d3-array')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-scale', 'd3-selection', 'd3-path', 'd3-shape', 'd3-array'], factory) :
    (global = global || self, factory(global.fc = global.fc || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Scale, d3Selection, d3Path, d3Shape, d3Array) { 'use strict';

    var d3Scale__default = 'default' in d3Scale ? d3Scale['default'] : d3Scale;
    var d3Shape__default = 'default' in d3Shape ? d3Shape['default'] : d3Shape;

    // "Caution: avoid interpolating to or from the number zero when the interpolator is used to generate
    // a string (such as with attr).
    // Very small values, when stringified, may be converted to scientific notation and
    // cause a temporarily invalid attribute or style property value.
    // For example, the number 0.0000001 is converted to the string "1e-7".
    // This is particularly noticeable when interpolating opacity values.
    // To avoid scientific notation, start or end the transition at 1e-6,
    // which is the smallest value that is not stringified in exponential notation."
    // - https://github.com/mbostock/d3/wiki/Transitions#d3_interpolateNumber
    const effectivelyZero = 1e-6; // Wrapper around d3's selectAll/data data-join, which allows decoration of the result.
    // This is achieved by appending the element to the enter selection before exposing it.
    // A default transition of fade in/out is also implicitly added but can be modified.

    var dataJoin = ((element, className) => {
      element = element || 'g';

      let key = (_, i) => i;

      let explicitTransition = null;

      const dataJoin = function (container, data) {
        data = data || (d => d);

        const implicitTransition = container.selection ? container : null;

        if (implicitTransition) {
          container = container.selection();
        }

        const selected = container.selectAll((d, i, nodes) => Array.from(nodes[i].childNodes).filter(node => node.nodeType === 1)).filter(className == null ? element : `${element}.${className}`);
        let update = selected.data(data, key);
        const enter = update.enter().append(element).attr('class', className);
        let exit = update.exit(); // automatically merge in the enter selection

        update = update.merge(enter); // if transitions are enabled apply a default fade in/out transition

        const transition = implicitTransition || explicitTransition;

        if (transition) {
          update = update.transition(transition).style('opacity', 1);
          enter.style('opacity', effectivelyZero);
          exit = exit.transition(transition).style('opacity', effectivelyZero);
        }

        exit.remove();

        update.enter = () => enter;

        update.exit = () => exit;

        return update;
      };

      dataJoin.element = (...args) => {
        if (!args.length) {
          return element;
        }

        element = args[0];
        return dataJoin;
      };

      dataJoin.className = (...args) => {
        if (!args.length) {
          return className;
        }

        className = args[0];
        return dataJoin;
      };

      dataJoin.key = (...args) => {
        if (!args.length) {
          return key;
        }

        key = args[0];
        return dataJoin;
      };

      dataJoin.transition = (...args) => {
        if (!args.length) {
          return explicitTransition;
        }

        explicitTransition = args[0];
        return dataJoin;
      };

      return dataJoin;
    });

    var functor = (v => typeof v === 'function' ? v : () => v);

    // bar has a fixed width, whilst the x, y and height are obtained from each data
    // point via the supplied accessor functions.

    var shapeBar = (() => {
      let context = null;

      let x = d => d.x;

      let y = d => d.y;

      let horizontalAlign = 'center';
      let verticalAlign = 'center';

      let height = d => d.height;

      let width = functor(3);

      const bar = function (data, index) {
        const drawingContext = context || d3Path.path();
        data.forEach(function (d, i) {
          const xValue = x.call(this, d, index || i);
          const yValue = y.call(this, d, index || i);
          const barHeight = height.call(this, d, index || i);
          const barWidth = width.call(this, d, index || i);
          let horizontalOffset;

          switch (horizontalAlign) {
            case 'left':
              horizontalOffset = barWidth;
              break;

            case 'right':
              horizontalOffset = 0;
              break;

            case 'center':
              horizontalOffset = barWidth / 2;
              break;

            default:
              throw new Error('Invalid horizontal alignment ' + horizontalAlign);
          }

          let verticalOffset;

          switch (verticalAlign) {
            case 'bottom':
              verticalOffset = -barHeight;
              break;

            case 'top':
              verticalOffset = 0;
              break;

            case 'center':
              verticalOffset = barHeight / 2;
              break;

            default:
              throw new Error('Invalid vertical alignment ' + verticalAlign);
          }

          drawingContext.rect(xValue - horizontalOffset, yValue - verticalOffset, barWidth, barHeight);
        }, this);
        return context ? null : drawingContext.toString();
      };

      bar.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return bar;
      };

      bar.x = (...args) => {
        if (!args.length) {
          return x;
        }

        x = functor(args[0]);
        return bar;
      };

      bar.y = (...args) => {
        if (!args.length) {
          return y;
        }

        y = functor(args[0]);
        return bar;
      };

      bar.width = (...args) => {
        if (!args.length) {
          return width;
        }

        width = functor(args[0]);
        return bar;
      };

      bar.horizontalAlign = (...args) => {
        if (!args.length) {
          return horizontalAlign;
        }

        horizontalAlign = args[0];
        return bar;
      };

      bar.height = (...args) => {
        if (!args.length) {
          return height;
        }

        height = functor(args[0]);
        return bar;
      };

      bar.verticalAlign = (...args) => {
        if (!args.length) {
          return verticalAlign;
        }

        verticalAlign = args[0];
        return bar;
      };

      return bar;
    });

    var constant = (function (value) {
      return typeof value === 'function' ? value : function () {
        return value;
      };
    });

    var band = (function () {
      var xScale = d3Scale.scaleIdentity();
      var yScale = d3Scale.scaleIdentity();
      var orient = 'horizontal';

      var fromValue = function fromValue(d) {
        return d.from;
      };

      var toValue = function toValue(d) {
        return d.to;
      };

      var decorate = function decorate() {};

      var join = dataJoin('g', 'annotation-band');
      var pathGenerator = shapeBar().horizontalAlign('center').verticalAlign('center').x(0).y(0);

      var instance = function instance(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        if (orient !== 'horizontal' && orient !== 'vertical') {
          throw new Error('Invalid orientation');
        }

        var horizontal = orient === 'horizontal';
        var translation = horizontal ? function (a, b) {
          return "translate(".concat(a, ", ").concat(b, ")");
        } : function (a, b) {
          return "translate(".concat(b, ", ").concat(a, ")");
        }; // the value scale which the annotation 'value' relates to, the crossScale
        // is the other. Which is which depends on the orienation!

        var crossScale = horizontal ? xScale : yScale;
        var valueScale = horizontal ? yScale : xScale;
        var crossScaleRange = crossScale.range();
        var crossScaleSize = crossScaleRange[1] - crossScaleRange[0];
        var valueAxisDimension = horizontal ? 'height' : 'width';
        var crossAxisDimension = horizontal ? 'width' : 'height';

        var containerTransform = function containerTransform() {
          return translation((crossScaleRange[1] + crossScaleRange[0]) / 2, (valueScale(toValue.apply(void 0, arguments)) + valueScale(fromValue.apply(void 0, arguments))) / 2);
        };

        pathGenerator[crossAxisDimension](crossScaleSize);
        pathGenerator[valueAxisDimension](function () {
          return valueScale(toValue.apply(void 0, arguments)) - valueScale(fromValue.apply(void 0, arguments));
        });
        selection.each(function (data, index, nodes) {
          var g = join(d3Selection.select(nodes[index]), data);
          g.enter().attr('transform', containerTransform).append('path').classed('band', true);
          g.attr('class', "annotation-band ".concat(orient)).attr('transform', containerTransform).select('path') // the path generator is being used to render a single path, hence
          // an explicit index is provided
          .attr('d', function (d, i) {
            return pathGenerator([d], i);
          });
          decorate(g, data, index);
        });
      };

      instance.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.fromValue = function () {
        if (!arguments.length) {
          return fromValue;
        }

        fromValue = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      instance.toValue = function () {
        if (!arguments.length) {
          return toValue;
        }

        toValue = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      return instance;
    });

    var createReboundMethod = ((target, source, name) => {
      const method = source[name];

      if (typeof method !== 'function') {
        throw new Error(`Attempt to rebind ${name} which isn't a function on the source object`);
      }

      return (...args) => {
        var value = method.apply(source, args);
        return value === source ? target : value;
      };
    });

    var rebind = ((target, source, ...names) => {
      for (const name of names) {
        target[name] = createReboundMethod(target, source, name);
      }

      return target;
    });

    const createTransform = transforms => name => transforms.reduce((name, fn) => name && fn(name), name);

    var rebindAll = ((target, source, ...transforms) => {
      const transform = createTransform(transforms);

      for (const name of Object.keys(source)) {
        const result = transform(name);

        if (result) {
          target[result] = createReboundMethod(target, source, name);
        }
      }

      return target;
    });

    var regexify = (strsOrRegexes => strsOrRegexes.map(strOrRegex => typeof strOrRegex === 'string' ? new RegExp(`^${strOrRegex}$`) : strOrRegex));

    var exclude = ((...exclusions) => {
      exclusions = regexify(exclusions);
      return name => exclusions.every(exclusion => !exclusion.test(name)) && name;
    });

    var include = ((...inclusions) => {
      inclusions = regexify(inclusions);
      return name => inclusions.some(inclusion => inclusion.test(name)) && name;
    });

    var includeMap = (mappings => name => mappings[name]);

    const capitalizeFirstLetter = str => str[0].toUpperCase() + str.slice(1);

    var prefix = (prefix => name => prefix + capitalizeFirstLetter(name));

    var band$1 = (function () {
      var xScale = d3Scale.scaleIdentity();
      var yScale = d3Scale.scaleIdentity();
      var orient = 'horizontal';

      var fromValue = function fromValue(d) {
        return d.from;
      };

      var toValue = function toValue(d) {
        return d.to;
      };

      var decorate = function decorate() {};

      var pathGenerator = shapeBar().horizontalAlign('right').verticalAlign('top');

      var instance = function instance(data) {
        if (orient !== 'horizontal' && orient !== 'vertical') {
          throw new Error('Invalid orientation');
        }

        var context = pathGenerator.context();
        var horizontal = orient === 'horizontal'; // the value scale which the annotation 'value' relates to, the crossScale
        // is the other. Which is which depends on the orienation!

        var crossScale = horizontal ? xScale : yScale;
        var valueScale = horizontal ? yScale : xScale;
        var crossScaleRange = crossScale.range();
        var crossScaleSize = crossScaleRange[1] - crossScaleRange[0];
        var valueAxisStart = horizontal ? 'x' : 'y';
        var crossAxisStart = horizontal ? 'y' : 'x';
        var valueAxisDimension = horizontal ? 'height' : 'width';
        var crossAxisDimension = horizontal ? 'width' : 'height';
        data.forEach(function (d, i) {
          context.save();
          context.beginPath();
          context.strokeStyle = 'transparent';
          pathGenerator[crossAxisStart](valueScale(fromValue(d)));
          pathGenerator[valueAxisStart](crossScaleRange[0]);
          pathGenerator[crossAxisDimension](crossScaleSize);
          pathGenerator[valueAxisDimension](valueScale(toValue(d)) - valueScale(fromValue(d)));
          decorate(context, d, i);
          pathGenerator.context(context)([d], i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      instance.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.fromValue = function () {
        if (!arguments.length) {
          return fromValue;
        }

        fromValue = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      instance.toValue = function () {
        if (!arguments.length) {
          return toValue;
        }

        toValue = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      rebind(instance, pathGenerator, 'context');
      return instance;
    });

    var annotationLine = (function () {
      var xScale = d3Scale.scaleIdentity();
      var yScale = d3Scale.scaleIdentity();

      var value = function value(d) {
        return d;
      };

      var label = value;

      var decorate = function decorate() {};

      var orient = 'horizontal';
      var join = dataJoin('g', 'annotation-line');

      var instance = function instance(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        if (orient !== 'horizontal' && orient !== 'vertical') {
          throw new Error('Invalid orientation');
        }

        var horizontal = orient === 'horizontal';
        var translation = horizontal ? function (a, b) {
          return "translate(".concat(a, ", ").concat(b, ")");
        } : function (a, b) {
          return "translate(".concat(b, ", ").concat(a, ")");
        };
        var lineProperty = horizontal ? 'x2' : 'y2'; // the value scale which the annotation 'value' relates to, the crossScale
        // is the other. Which is which depends on the orienation!

        var crossScale = horizontal ? xScale : yScale;
        var valueScale = horizontal ? yScale : xScale;
        var handleOne = horizontal ? 'left-handle' : 'bottom-handle';
        var handleTwo = horizontal ? 'right-handle' : 'top-handle';
        var textOffsetX = horizontal ? '9' : '0';
        var textOffsetY = horizontal ? '0' : '9';
        var textOffsetDeltaY = horizontal ? '0.32em' : '0.71em';
        var textAnchor = horizontal ? 'start' : 'middle';
        var scaleRange = crossScale.range(); // the transform that sets the 'origin' of the annotation

        var containerTransform = function containerTransform() {
          return translation(scaleRange[0], valueScale(value.apply(void 0, arguments)));
        };

        var scaleWidth = scaleRange[1] - scaleRange[0];
        selection.each(function (data, selectionIndex, nodes) {
          var g = join(d3Selection.select(nodes[selectionIndex]), data); // create the outer container and line

          var enter = g.enter().attr('transform', containerTransform).style('stroke', '#bbb');
          enter.append('line').attr(lineProperty, scaleWidth); // create containers at each end of the annotation

          enter.append('g').classed(handleOne, true).style('stroke', 'none');
          enter.append('g').classed(handleTwo, true).style('stroke', 'none').attr('transform', translation(scaleWidth, 0)).append('text').attr('text-anchor', textAnchor).attr('x', textOffsetX).attr('y', textOffsetY).attr('dy', textOffsetDeltaY); // Update

          g.attr('class', "annotation-line ".concat(orient)); // translate the parent container to the left hand edge of the annotation

          g.attr('transform', containerTransform); // update the elements that depend on scale width

          g.select('line').attr(lineProperty, scaleWidth);
          g.select('g.' + handleTwo).attr('transform', translation(scaleWidth, 0)); // Update the text label

          g.select('text').text(label);
          decorate(g, data, selectionIndex);
        });
      };

      instance.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      instance.label = function () {
        if (!arguments.length) {
          return label;
        }

        label = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      instance.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      return instance;
    });

    var functor$1 = (d => typeof d === 'function' ? d : () => d);

    // Checks that passed properties are 'defined', meaning that calling them with (d, i) returns non null values
    function defined() {
      const outerArguments = arguments;
      return function (d, i) {
        for (let c = 0, j = outerArguments.length; c < j; c++) {
          if (outerArguments[c](d, i) == null) {
            return false;
          }
        }

        return true;
      };
    }

    // determines the offset required along the cross scale based
    // on the series alignment
    var alignOffset = ((align, width) => {
      switch (align) {
        case 'left':
          return width / 2;

        case 'right':
          return -width / 2;

        default:
          return 0;
      }
    });

    var createBase = (initialValues => {
      const env = Object.assign({}, initialValues);

      const base = () => {};

      Object.keys(env).forEach(key => {
        base[key] = (...args) => {
          if (!args.length) {
            return env[key];
          }

          env[key] = args[0];
          return base;
        };
      });
      return base;
    });

    var xyBase = (() => {
      let baseValue = () => 0;

      let crossValue = d => d.x;

      let mainValue = d => d.y;

      let align = 'center';

      let bandwidth = () => 5;

      let orient = 'vertical';
      const base = createBase({
        decorate: () => {},
        defined: (d, i) => defined(baseValue, crossValue, mainValue)(d, i),
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      base.values = (d, i) => {
        const width = bandwidth(d, i);
        const offset = alignOffset(align, width);
        const xScale = base.xScale();
        const yScale = base.yScale();

        if (orient === 'vertical') {
          const y = yScale(mainValue(d, i), i);
          const y0 = yScale(baseValue(d, i), i);
          const x = xScale(crossValue(d, i), i) + offset;
          return {
            d,
            x,
            y,
            y0,
            width,
            height: y - y0,
            origin: [x, y],
            baseOrigin: [x, y0],
            transposedX: x,
            transposedY: y
          };
        } else {
          const y = xScale(mainValue(d, i), i);
          const y0 = xScale(baseValue(d, i), i);
          const x = yScale(crossValue(d, i), i) + offset;
          return {
            d,
            x,
            y,
            y0,
            width,
            height: y - y0,
            origin: [y, x],
            baseOrigin: [y0, x],
            transposedX: y,
            transposedY: x
          };
        }
      };

      base.xValues = () => orient === 'vertical' ? [crossValue] : [baseValue, mainValue];

      base.yValues = () => orient !== 'vertical' ? [crossValue] : [baseValue, mainValue];

      base.baseValue = (...args) => {
        if (!args.length) {
          return baseValue;
        }

        baseValue = functor$1(args[0]);
        return base;
      };

      base.crossValue = (...args) => {
        if (!args.length) {
          return crossValue;
        }

        crossValue = functor$1(args[0]);
        return base;
      };

      base.mainValue = (...args) => {
        if (!args.length) {
          return mainValue;
        }

        mainValue = functor$1(args[0]);
        return base;
      };

      base.bandwidth = (...args) => {
        if (!args.length) {
          return bandwidth;
        }

        bandwidth = functor$1(args[0]);
        return base;
      };

      base.align = (...args) => {
        if (!args.length) {
          return align;
        }

        align = args[0];
        return base;
      };

      base.orient = (...args) => {
        if (!args.length) {
          return orient;
        }

        orient = args[0];
        return base;
      };

      return base;
    });

    const red = '#c60';
    const green = '#6c0';
    const black = '#000';
    const gray = '#ddd';
    const darkGray = '#999';
    var colors = {
      red,
      green,
      black,
      gray,
      darkGray
    };

    var seriesSvgPoint = (() => {
      const symbol = d3Shape.symbol();
      const base = xyBase();
      const join = dataJoin('g', 'point');

      const containerTransform = origin => 'translate(' + origin[0] + ', ' + origin[1] + ')';

      const point = selection => {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each((data, index, group) => {
          const filteredData = data.filter(base.defined());
          const g = join(d3Selection.select(group[index]), filteredData);
          g.enter().attr('transform', (d, i) => containerTransform(base.values(d, i).origin)).attr('fill', colors.gray).attr('stroke', colors.black).append('path');
          g.attr('transform', (d, i) => containerTransform(base.values(d, i).origin)).select('path').attr('d', symbol);
          base.decorate()(g, data, index);
        });
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, join, 'key');
      rebind(point, symbol, 'type', 'size');
      return point;
    });

    var seriesCanvasPoint = (() => {
      const symbol = d3Shape.symbol();
      const base = xyBase();

      const point = data => {
        const filteredData = data.filter(base.defined());
        const context = symbol.context();
        filteredData.forEach((d, i) => {
          context.save();
          const values = base.values(d, i);
          context.translate(values.origin[0], values.origin[1]);
          context.beginPath();
          context.strokeStyle = colors.black;
          context.fillStyle = colors.gray;
          base.decorate()(context, d, i);
          symbol(d, i);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      rebindAll(point, base, exclude('baseValue', 'bandwidth', 'align'));
      rebind(point, symbol, 'size', 'type', 'context');
      return point;
    });

    var multiBase = (() => {
      let series = [];

      let mapping = d => d;

      let key = (_, i) => i;

      const multi = createBase({
        decorate: () => {},
        xScale: d3Scale.scaleIdentity(),
        yScale: d3Scale.scaleIdentity()
      });

      multi.xValues = () => series.map(s => s.xValues()).reduce((a, b) => a.concat(b));

      multi.yValues = () => series.map(s => s.yValues()).reduce((a, b) => a.concat(b));

      multi.mapping = (...args) => {
        if (!args.length) {
          return mapping;
        }

        mapping = args[0];
        return multi;
      };

      multi.key = (...args) => {
        if (!args.length) {
          return key;
        }

        key = args[0];
        return multi;
      };

      multi.series = (...args) => {
        if (!args.length) {
          return series;
        }

        series = args[0];
        return multi;
      };

      return multi;
    });

    var seriesSvgMulti = (() => {
      const base = multiBase();
      const innerJoin = dataJoin('g');
      const join = dataJoin('g', 'multi');

      const multi = selection => {
        if (selection.selection) {
          join.transition(selection);
          innerJoin.transition(selection);
        }

        const mapping = base.mapping();
        const series = base.series();
        const xScale = base.xScale();
        const yScale = base.yScale();
        selection.each((data, index, group) => {
          const container = join(d3Selection.select(group[index]), series); // iterate over the containers, 'call'-ing the series for each

          container.each((dataSeries, seriesIndex, seriesGroup) => {
            dataSeries.xScale(xScale).yScale(yScale);
            const seriesData = mapping(data, seriesIndex, series);
            const innerContainer = innerJoin(d3Selection.select(seriesGroup[seriesIndex]), [seriesData]);
            innerContainer.call(dataSeries);
          });
          const unwrappedSelection = container.selection ? container.selection() : container;
          unwrappedSelection.order();
          base.decorate()(container, data, index);
        });
      };

      rebindAll(multi, base);
      rebind(multi, join, 'key');
      return multi;
    });

    var seriesCanvasMulti = (() => {
      let context = null;
      const base = multiBase();

      const multi = data => {
        const mapping = base.mapping();
        const series = base.series();
        const xScale = base.xScale();
        const yScale = base.yScale();
        series.forEach((dataSeries, index) => {
          const seriesData = mapping(data, index, series);
          dataSeries.context(context).xScale(xScale).yScale(yScale);
          let adaptedDecorate;

          if (dataSeries.decorate) {
            adaptedDecorate = dataSeries.decorate();
            dataSeries.decorate((c, d, i) => {
              base.decorate()(c, data, index);
              adaptedDecorate(c, d, i);
            });
          } else {
            base.decorate()(context, data, index);
          }

          dataSeries(seriesData);

          if (adaptedDecorate) {
            dataSeries.decorate(adaptedDecorate);
          }
        });
      };

      multi.context = (...args) => {
        if (!args.length) {
          return context;
        }

        context = args[0];
        return multi;
      };

      rebindAll(multi, base);
      return multi;
    });

    function crosshair () {
      var x = function x(d) {
        return d.x;
      };

      var y = function y(d) {
        return d.y;
      };

      var xScale = d3Scale.scaleIdentity();
      var yScale = d3Scale.scaleIdentity();

      var decorate = function decorate() {};

      var join = dataJoin('g', 'annotation-crosshair');
      var point = seriesSvgPoint();
      var horizontalLine = annotationLine();
      var verticalLine = annotationLine().orient('vertical'); // The line annotations and point series used to render the crosshair are positioned using
      // screen coordinates. This function constructs an identity scale for these components.

      var xIdentity = d3Scale.scaleIdentity();
      var yIdentity = d3Scale.scaleIdentity();
      var multi = seriesSvgMulti().series([horizontalLine, verticalLine, point]).xScale(xIdentity).yScale(yIdentity).mapping(function (data) {
        return [data];
      });

      var instance = function instance(selection) {
        if (selection.selection) {
          join.transition(selection);
        }

        selection.each(function (data, index, nodes) {
          var g = join(d3Selection.select(nodes[index]), data); // Prevent the crosshair triggering pointer events on itself

          g.enter().style('pointer-events', 'none'); // Assign the identity scales an accurate range to allow the line annotations to cover
          // the full width/height of the chart.

          xIdentity.range(xScale.range());
          yIdentity.range(yScale.range());
          point.crossValue(x).mainValue(y);
          horizontalLine.value(y);
          verticalLine.value(x);
          g.call(multi);
          decorate(g, data, index);
        });
      }; // Don't use the xValue/yValue convention to indicate that these values are in screen
      // not domain co-ordinates and are therefore not scaled.


      instance.x = function () {
        if (!arguments.length) {
          return x;
        }

        x = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.y = function () {
        if (!arguments.length) {
          return y;
        }

        y = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      var lineIncludes = include('label');
      rebindAll(instance, horizontalLine, lineIncludes, prefix('y'));
      rebindAll(instance, verticalLine, lineIncludes, prefix('x'));
      return instance;
    }

    var annotationLine$1 = (function () {
      var xScale = d3Scale.scaleIdentity();
      var yScale = d3Scale.scaleIdentity();

      var value = function value(d) {
        return d;
      };

      var label = value;

      var decorate = function decorate() {};

      var orient = 'horizontal';
      var lineData = d3Shape.line();

      var instance = function instance(data) {
        if (orient !== 'horizontal' && orient !== 'vertical') {
          throw new Error('Invalid orientation');
        }

        var horizontal = orient === 'horizontal';
        var context = lineData.context(); // the value scale which the annotation 'value' relates to, the crossScale
        // is the other. Which is which depends on the orienation!

        var crossScale = horizontal ? xScale : yScale;
        var valueScale = horizontal ? yScale : xScale;
        var crossDomain = crossScale.domain();
        var textOffsetX = horizontal ? 9 : 0;
        var textOffsetY = horizontal ? 0 : 9;
        var textAlign = horizontal ? 'left' : 'center';
        var textBaseline = horizontal ? 'middle' : 'hanging';
        data.forEach(function (d, i) {
          context.save();
          context.beginPath();
          context.strokeStyle = '#bbb';
          context.fillStyle = '#000';
          context.textAlign = textAlign;
          context.textBaseline = textBaseline;
          decorate(context, d, i); // Draw line

          lineData.context(context)(crossDomain.map(function (extent) {
            var point = [crossScale(extent), valueScale(value(d))];
            return horizontal ? point : point.reverse();
          })); // Draw label

          var x = horizontal ? crossScale(crossDomain[1]) : valueScale(value(d));
          var y = horizontal ? valueScale(value(d)) : crossScale(crossDomain[1]);
          context.fillText(label(d), x + textOffsetX, y + textOffsetY);
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      instance.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.value = function () {
        if (!arguments.length) {
          return value;
        }

        value = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      instance.label = function () {
        if (!arguments.length) {
          return label;
        }

        label = constant(arguments.length <= 0 ? undefined : arguments[0]);
        return instance;
      };

      instance.decorate = function () {
        if (!arguments.length) {
          return decorate;
        }

        decorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.orient = function () {
        if (!arguments.length) {
          return orient;
        }

        orient = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      rebind(instance, lineData, 'context');
      return instance;
    });

    var crosshair$1 = (function () {
      var x = function x(d) {
        return d.x;
      };

      var y = function y(d) {
        return d.y;
      };

      var xScale = d3Scale.scaleIdentity();
      var yScale = d3Scale.scaleIdentity();
      var point = seriesCanvasPoint();
      var horizontalLine = annotationLine$1();
      var verticalLine = annotationLine$1().orient('vertical'); // The line annotations and point series used to render the crosshair are positioned using
      // screen coordinates. This function constructs an identity scale for these components.

      var xIdentity = d3Scale.scaleIdentity();
      var yIdentity = d3Scale.scaleIdentity();
      var multi = seriesCanvasMulti().series([horizontalLine, verticalLine, point]).xScale(xIdentity).yScale(yIdentity).mapping(function (data) {
        return [data];
      });

      var instance = function instance(data) {
        data.forEach(function (d) {
          // Assign the identity scales an accurate range to allow the line annotations to cover
          // the full width/height of the chart.
          xIdentity.range(xScale.range());
          yIdentity.range(yScale.range());
          point.crossValue(x).mainValue(y);
          horizontalLine.value(y);
          verticalLine.value(x);
          multi(d);
        });
      }; // Don't use the xValue/yValue convention to indicate that these values are in screen
      // not domain co-ordinates and are therefore not scaled.


      instance.x = function () {
        if (!arguments.length) {
          return x;
        }

        x = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.y = function () {
        if (!arguments.length) {
          return y;
        }

        y = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.xScale = function () {
        if (!arguments.length) {
          return xScale;
        }

        xScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.yScale = function () {
        if (!arguments.length) {
          return yScale;
        }

        yScale = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      var lineIncludes = include('label', 'decorate');
      rebindAll(instance, horizontalLine, lineIncludes, prefix('y'));
      rebindAll(instance, verticalLine, lineIncludes, prefix('x'));
      rebind(instance, point, 'decorate');
      rebind(instance, multi, 'context');
      return instance;
    });

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

        return arr2;
      }
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    var ticks = (function () {
      var scale = d3Scale.scaleIdentity();
      var tickArguments = [10];
      var tickValues = null;

      var ticks = function ticks() {
        var _scale;

        return tickValues != null ? tickValues : scale.ticks ? (_scale = scale).ticks.apply(_scale, _toConsumableArray(tickArguments)) : scale.domain();
      };

      ticks.scale = function () {
        if (!arguments.length) {
          return scale;
        }

        scale = arguments.length <= 0 ? undefined : arguments[0];
        return ticks;
      };

      ticks.ticks = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        tickArguments = args;
        return ticks;
      };

      ticks.tickArguments = function () {
        if (!arguments.length) {
          return tickArguments;
        }

        tickArguments = arguments.length <= 0 ? undefined : arguments[0];
        return ticks;
      };

      ticks.tickValues = function () {
        if (!arguments.length) {
          return tickValues;
        }

        tickValues = arguments.length <= 0 ? undefined : arguments[0];
        return ticks;
      };

      return ticks;
    });

    var identity = function identity(d) {
      return d;
    };

    var gridline = (function () {
      var xDecorate = function xDecorate() {};

      var yDecorate = function yDecorate() {};

      var xTicks = ticks();
      var yTicks = ticks();
      var xJoin = dataJoin('line', 'gridline-y').key(identity);
      var yJoin = dataJoin('line', 'gridline-x').key(identity);

      var instance = function instance(selection) {
        if (selection.selection) {
          xJoin.transition(selection);
          yJoin.transition(selection);
        }

        selection.each(function (data, index, nodes) {
          var element = nodes[index];
          var container = d3Selection.select(nodes[index]);
          var xScale = xTicks.scale();
          var yScale = yTicks.scale(); // Stash a snapshot of the scale, and retrieve the old snapshot.

          var xScaleOld = element.__x_scale__ || xScale;
          element.__x_scale__ = xScale.copy();
          var xData = xTicks();
          var xLines = xJoin(container, xData);
          xLines.enter().attr('x1', xScaleOld).attr('x2', xScaleOld).attr('y1', yScale.range()[0]).attr('y2', yScale.range()[1]);
          xLines.attr('x1', xScale).attr('x2', xScale).attr('y1', yScale.range()[0]).attr('y2', yScale.range()[1]).attr('stroke', '#bbb');
          xLines.exit().attr('x1', xScale).attr('x2', xScale);
          xDecorate(xLines, xData, index); // Stash a snapshot of the scale, and retrieve the old snapshot.

          var yScaleOld = element.__y_scale__ || yScale;
          element.__y_scale__ = yScale.copy();
          var yData = yTicks();
          var yLines = yJoin(container, yData);
          yLines.enter().attr('y1', yScaleOld).attr('y2', yScaleOld).attr('x1', xScale.range()[0]).attr('x2', xScale.range()[1]);
          yLines.attr('y1', yScale).attr('y2', yScale).attr('x1', xScale.range()[0]).attr('x2', xScale.range()[1]).attr('stroke', '#bbb');
          yLines.exit().attr('y1', yScale).attr('y2', yScale);
          yDecorate(yLines, yData, index);
        });
      };

      instance.yDecorate = function () {
        if (!arguments.length) {
          return yDecorate;
        }

        yDecorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.xDecorate = function () {
        if (!arguments.length) {
          return xDecorate;
        }

        xDecorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      rebindAll(instance, xJoin, includeMap({
        'key': 'xKey'
      }));
      rebindAll(instance, yJoin, includeMap({
        'key': 'yKey'
      }));
      rebindAll(instance, xTicks, prefix('x'));
      rebindAll(instance, yTicks, prefix('y'));
      return instance;
    });

    var gridline$1 = (function () {
      var xDecorate = function xDecorate() {};

      var yDecorate = function yDecorate() {};

      var xTicks = ticks();
      var yTicks = ticks();
      var lineData = d3Shape.line();

      var instance = function instance() {
        var context = lineData.context();
        var xScale = xTicks.scale();
        var yScale = yTicks.scale();
        xTicks().forEach(function (xTick, i) {
          context.save();
          context.beginPath();
          context.strokeStyle = '#bbb';
          context.fillStyle = 'transparent';
          xDecorate(context, xTick, i);
          lineData.context(context)(yScale.domain().map(function (d) {
            return [xScale(xTick), yScale(d)];
          }));
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
        yTicks().forEach(function (yTick, i) {
          context.save();
          context.beginPath();
          context.strokeStyle = '#bbb';
          context.fillStyle = 'transparent';
          yDecorate(context, yTick, i);
          lineData.context(context)(xScale.domain().map(function (d) {
            return [xScale(d), yScale(yTick)];
          }));
          context.fill();
          context.stroke();
          context.closePath();
          context.restore();
        });
      };

      instance.yDecorate = function () {
        if (!arguments.length) {
          return yDecorate;
        }

        yDecorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      instance.xDecorate = function () {
        if (!arguments.length) {
          return xDecorate;
        }

        xDecorate = arguments.length <= 0 ? undefined : arguments[0];
        return instance;
      };

      rebindAll(instance, xTicks, prefix('x'));
      rebindAll(instance, yTicks, prefix('y'));
      rebind(instance, lineData, 'context');
      return instance;
    });

    exports.annotationCanvasBand = band$1;
    exports.annotationCanvasCrosshair = crosshair$1;
    exports.annotationCanvasGridline = gridline$1;
    exports.annotationCanvasLine = annotationLine$1;
    exports.annotationSvgBand = band;
    exports.annotationSvgCrosshair = crosshair;
    exports.annotationSvgGridline = gridline;
    exports.annotationSvgLine = annotationLine;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
